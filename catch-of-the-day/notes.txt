# Video No, 1 -  Tooling and Editor Setup

    * Instead of popping in a new script tag into index.html every time we need a new dependency, we'll be writing all our code in our index.js file in the src directory as well as in the components that we will be creating.
    * We will import all of the libraries as we need them. We will be importing React, React DOM, and any other modules we need.
    * Everything in React is a component.
    * component: re-usable piece of a website. React allows you to build your own tags or `components`, as they are called in React. You can also supply those tags with a whole bunch of information.

# Video No. 3 - Creating Our First Components

* Anything that is written in index.js will be bundled into our bundle.js file.
* Creating first component:

```javascript
class StorePicker extends React.Component {
    render() {
        // returns some jsx
        return <p>Hello</p>
    }
}
```

* How do we actually get the jsx to render onto the page?:

```html
<div id="main">
  <!-- This is where our React app will go -->
</div>
```

* The `#main` div is called a `mounting point`.

* We need to go and grab `React DOM`. Where React renders out to is not just to html. It can be Android, iOS, etc. In our case here, however, we want it to render to html. So we need to import the `render()` method from `react-dom`. We do this because we do not need the entire ReactDOM package. If we were to import the entire package, we would do it thus:

```javascript
import ReactDOM from 'react-dom';
```

and then

```javascript
ReactDOM.render()
```

* Every single component that we create in React needs at least one method, and that is the render() method. When a component is rendered to the page, it will ask the class (in this case StorePicker) what `html` should it display.

* First component we build: store picker component.
    * type in the name of the store or auto-fill it with a funny one, and then a click of the provided button takes the user to that store.

* It's a BEST PRACTICE to put each of your components in a separate file. This way it is much easier to maintain the component.

* So for our first component called StorePicker, we create a file in the components folder located in the src directory and call it StorePicker.js. It should be named exactly as the component is named. Cut out StorePicker component code in index.js

```javascript
class StorePicker extends React.Component {
	render() {
        // returns some jsx
		return <p>Hello</p>

	}
}
```

and paste it into StorePicker.js.

* We also need to import React from react. Have to do that at the top over every component. Then export StorePicker

```javascript
export default StorePicker;
```

The export permits us to import it in index.js.

# Video 4 - Writing HTML With JSX

* **jsx:** allows us to write html right inside of our JS. While it is NOT REQUIRED by React, pretty much everyone uses it. The alternative would be:

```javascript
render() {
    return React.createElement('p', {className: 'Testing'}, 'I love React');
}
```

* But it's a pain to do that especially when you are nesting things.

* With JSX, you can't use `class=""` when adding a class to an html tag. You have to use `className`. That's because class is a reserved name in JavaScript, so both React and JSX disallow it.

* With JSX, you can only ever return one parent element. In other words, you can add as much html as you want within one parent tag and return it, but you cannot place another `parent` tag below it and return both. One way to work around that is to wrap the `child` tags into one `div` and return that `div`.

* With JSX, you HAVE to self close tags such as input, img etc. Unlike html5 where you no longer have to.

* Writing COMMENTS in JSX: { /* */ }. You can use regular JS comments anywhere else. It's just when you enter the JSX (like render()) that you have to use this type of comment.

* If you put your comment RIGHT ABOVE whatever it is you are going to return, like our `<form></form>` element for example, it will disappear from the page. That's because JSX thinks we are trying to return two things. It treats the comment as another thing. You can place it above the JSX as well.

# Video No. 5 - Loading CSS into our React Application

* You can include a link tag for your CSS in your index.html and everything would be rendered just fine. But there are a couple of other ways to approach your CSS:

    * can import the CSS file into index.js along with everything else:

```javascript
import './css/style.css';
```

* That will take everything that is inside of `style.css`, `webpack` **compiles** it all, and it pops a style tag on the `index.html` page for us. Sounds good to me!

* Some people have separate css files for every component. That's a bit more of an advanced topic, but it would mean having more control and more re-usability of specific components to include the CSS as well. Will have to look into this when I am more comfortable with React.

# Video No. 6 - Creating our application layout with components

# Video No. 7 - Passing Dynamic data with props

* Question: How do you dynamically get data from one component to another? Once way is with something called `props`.

* React `props` work the same way as `html tag` **attributes**. If you want to pass information to a tag, you would do it via a `prop`.

* How do you put place variables into JSX?: You delete the text between the tags, open up one set of curly brackets, and

```javascript
{this.props.tagline}
```
for instance. `this` refers to the component. In this case, `Header`. `props` is an object available to us. Then you can do props.tagline, .age, or whatever other property you want to tag onto the object. Those actually are equivalent to the attributes of an element, and in React are the `props`.

* If I add `console.log(this)` above `return ()` in `Header.js`, I will see that the Header component now shows up in the console. Inside the Header component, I will find props. You can use `this.props.whatever` anywhere inside the `return ()` render method, and it will be made available to you.

* `($r in the console)` in React DevTools: If you ever just need to play with the React DevTools, you click on the component you want to play with, go back to the console, type in `$r`, and that will become equal to the component you chose to play with. Then you could go

```javascript
$r.props.tagline
```

for example, and the console would return the value of the tagline.

* **prop types:** allow you to validate that a. data is passed. b. the dataa that IS passed, is the correct type. helps you make nicer, more strictly made components.

# Video No. 8 - Stateless Functional Components

* Sometimes all a component will do is render some html to the page. In that case, you do not need a full component. All you need is a `stateless functional component`. What that means is that if you don't need other methods  other than `render()`, it doesn't make sense to use an `entire` React Component. You can just use a `stateless functional component`. Taht will be used to `render out` our `JSX`.

* So how do you `convert` a `React Component` to a `stateless functional component`?:
    * First delete the opening and closing curly brackets for the component class and then the class itself.
    * Next delete the `entire` **render();**
    * Just left with what we return.
    * Place the return in the value of a new variable that has the same name as the original complete React Component. the anonymous function that starts the value and encapsulates the return () has to have {}, just as the original, `complete React Component class`.
    * now that return () is stored in the value of the Header variable, `this` no longer refers to the same value. I can only guess what it does refer to lol. What else but window? So it should be removed from `{this.props.whatever}`.

# Video No. 9 - Routing with React Router

**Routing in React:** React isn't a framework. It's a library. Therefore, it doesn't solve all an application's needs. It does a great job at creating components and providing a system for managing state, but creating a more complex SPA requires a supporting cast. The first is `React Router`.

* **React Router:** uses `JSX`. But it's not part of React. It is however, the industry standard when you need routing inside of React.
* We use `React Router 4` here. It allows you to `show` and `hide` components anywhere inside your application depending on if you are on the page you wish to show them or not.
* This is what we are basically going to do, in index.js.
* We do need a couple of things to `import` from `React Router`.
* We need the `BrowserRouter`, `Match`, and `Miss`.
* Next thing we need to make a component which will be our router. Even the router itself is a component!
* We create a `stateless functional component` for the `React Router`.
* When we have created the Root component which stores the value of returning the `<BrowserRouter></BrowserRouter>`, we have to replace the rendering of `App` with `Root` so that what we have just created will render to the page.

Also,

```javascript
const Root = () => {
	return (
        <BrowserRouter>
			<div>
				<Match exactly pattern="/" component={StorePicker} />
				<Match exactly pattern="/store/:storeId" component={App} />
			</div>
        </BrowserRouter>
	)
}

render(<Root/>, document.querySelector('#main'));
```

We have to wrap a div around the two `Match` tags so that they are not direct children of <BrowserRouter>, Otherwise, JSX thinks that we are trying to render more than one component.

`Miss` used for when you type in the name of a store (url) that does not exist. It's a `miss`.

* When using props, if you are not passing a string, i.e., a number, a boolean, or a variable, you need to put it in curly brackets. In the case of `Miss`, {NotFound}.
* Need to create a component for NotFound.

**Important Note:** We are using `create-react-app` in the background, which hides hides the complexities of `webpack`. Why `create-react-app` is popular is because people want to develop with React and not care about transpiling ES6 to ES5 (and more) so `create-react-app` takes care of the `webpack` stuff behind the scenes. If you *REALLY*  want to see the webpack config file that `create-react-app` generates, run `npm eject`. However, it is not recommended while going through the course. We do that in the final video.

# Video No. 10 - Helper and Utility Functions

* **helper functions:** are NOT specific to React. We use them all throughout the App. When there is some specific functionality that is not necessarily tied to any one component, Wes suggests creating a `helpers` file. In this `helpers` file, we stick handy helper functions that are not big enough to be treated as modules, but they are `useful` functions that are used throughout the app.

* In order to access some of the functions in `helpers.js`, we want to open up `StorePicker.js`, go down to the input, and set a default value for when the page is loaded. So instead of stating `value=""` (value is tied to State, and we don't want to do that just yet), we just want a default value for when the page is loaded. So we implement defaultValue={getFunName()} and we also have to import it into `StorePicker.js`.

* Next will be to make it so that when the button is clicked, the url changes to the name of the random store that appears in the input text field.

# Video 11 - Working With React Events

* Events in React are exactly the same as events in regular JavaScript. The only difference with React events, is that they are wrapped in a cross-browser wrapper called `SyntheticEvent`.

`SyntheticEvent`: wraps around the browser's native event. It has the same (method) interface as the browser's native event, including things like `stopPropagation()` and `preventDefault()`, except that the events work identically across all browsers. NOT necessarily the case with regular JavaScript.

* In React, events are done `inline`. In regular `JavaScript` or `jQuery`, you have your html in one place, and you would write your javaScript somewhere else. The `JS` would then select that `html` and then go back and listen for a click on that event, for instance.

* In `React`, there isn't much separation that takes place. We attach an event via an `onClick` or an `onSubmit` event handler right inline, like some would do with JavaScript in index.html.

* When we click `submit` on the `visit store` button, a couple of things need to happen:

    * Need to pull whatever has been typed into the input text field and get it into React.
    * Transition the url from `/` onto `/store/` + whatever name the user has typed in the input.

* What event do we need to `listen` for? The `onSubmit` event.

* `render()` methods are bound to the class they are in. However, the custom methods we add, like `goToStore()`, are not, and we have to find a way to bind them. Since `render()` is bound to the class it is in, we can use `this` inside of it. And `this` will always be equal to the component.

Stopped at 4:06.
